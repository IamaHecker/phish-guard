# System Implementation Overview

## Front-End (Client Side)

The front end is the part of Phish Guard that users see and interact with in the browser. It focuses on being simple, clear, and easy to use for three main roles: **Admin**, **End User**, and **Analyst**. 

**Main interfaces**

* **Admin Dashboard**
  * Create, edit, and launch phishing campaigns.
  * Manage email templates (subject, body, links, landing pages).
  * View high-level statistics such as number of emails sent, open rate, click rate, and quiz completion.
  * Manage users and cohorts (e.g., specific departments or groups). 

* **End-User Interface**
  * Receives simulated phishing emails generated by the system.
  * When the user clicks a phishing link, they are redirected to:
    * A micro-training page that explains what they missed.
    * A short quiz to confirm that they understood the lesson. 

* **Analyst Dashboard**
  * Advanced view with charts and tables to analyze campaign performance.
  * Filter by campaign, user group, or time period.
  * Export report data for further analysis. 

**Front-end technologies**

* **HTML, CSS, JavaScript** – to build the pages, forms, and dashboards. 
* **Bootstrap** – to make the UI responsive and consistent across devices. 
* **AJAX / Fetch calls** – to communicate with the Flask backend APIs without reloading the page (for real-time stats and dynamic updates in dashboards). 

**Front-end responsibilities**

* Display forms for login, campaign creation, and template editing.
* Show tables and charts for analytics.
* Handle simple validation on the client side (e.g., required fields).
* Call backend REST APIs and render the data returned (campaign list, analytics, user progress).

---

## Back-End (Server Side)

The back end is the “brain” of Phish Guard. It processes requests, stores data, sends emails, and enforces security rules. It is built using **Python Flask** and a **relational database** (MySQL). 

**Core backend modules**

1. **Authentication & Authorization Module**
   * Handles login for admins, analysts, and normal users.
   * Role-based access control so that only admins can create campaigns, and only analysts can see advanced reports. 

2. **Campaign Management Module**
   * Create, update, schedule, and delete phishing campaigns.
   * Link campaigns to specific email templates and target cohorts.
   * Store campaign status (draft, scheduled, running, completed). 

3. **Email & SMTP Module**
   * Connects to an SMTP server using secure credentials.
   * Sends simulated phishing emails in batches to avoid throttling.
   * Logs delivery status and errors for troubleshooting. 

4. **Training & Quiz Module**
   * When a user clicks a phishing link, the backend:
     * Records the click.
     * Serves the correct training content page.
     * Stores quiz answers and pass/fail results. 

5. **Analytics & Reporting Module**
   * Aggregates data from user interactions: opens, clicks, quiz scores, and reporting behavior.
   * Exposes REST API endpoints that the dashboards can call to draw graphs and tables.
   * Supports exporting data (e.g., CSV) for further analysis. 

6. **Database Layer**
   * MySQL (or similar) stores:
     * Users and roles
     * Campaigns and templates
     * Cohorts / groups
     * Interaction logs (open, click, report, training completed)
     * Quiz results and scores 
   * SQLAlchemy (or similar ORM) is used to map Python classes to database tables, making queries easier and safer. 

7. **Security & Ethics Controls**
   * Anonymization or hashing of user identifiers in logs to protect privacy.
   * Secure handling of SMTP credentials and database URLs through configuration files (`config.py` and environment variables).
   * Following institutional ethical guidelines for simulations. 

---

## What Is Needed to Implement the Website

To actually build and run the Phish Guard website, you need both **technical stack** and **infrastructure/tools**.

### 1. Technical Stack

* **Backend**
  * Python 3
  * Flask framework
  * SQLAlchemy ORM
  * MySQL server (or compatible SQL DB) 
  * Libraries: `smtplib` (or a modern email library), `pandas` for analytics, testing tools like `pytest`. 

* **Frontend**
  * HTML5, CSS3, JavaScript
  * Bootstrap for layout and styling
  * Optional chart library (e.g., Chart.js) for analytics visualizations.

* **System Design**
  * UML models (use case, sequence, activity, class diagrams) created in **StarUML** to guide the implementation. 

### 2. Development Environment & Tools

* **IDE/Editor** – Visual Studio Code or similar, configured for Python and web development. 
* **Version Control** – Git + GitHub repository to manage all source code, diagrams, and documentation. 
* **Project Management Tools** – Trello for sprint boards and task tracking, Microsoft Teams for meetings and status updates. 

### 3. Infrastructure / Hosting

* **Development server**
  * Local machine running Flask in debug mode.
  * Local MySQL instance for development and testing.

* **Production / Prototype deployment**
  * A Linux server or cloud VM (e.g., Azure) hosting:
    * Gunicorn or uWSGI + Nginx/Apache to serve the Flask app.
    * MySQL database instance.
  * Secure SMTP configuration for sending simulated emails (can be campus SMTP or a provider that allows test emails). 

### 4. Non-technical Requirements

* Test users (e.g., staff or students) to participate in phishing simulations and micro-training. 
* Supervisor / client feedback (e.g., from AQU) to refine UI, training content, and reporting. 
